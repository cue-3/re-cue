name: Bump Version

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
      confirm_major:
        description: 'For major bumps: confirm breaking changes (type "BREAKING")'
        required: false
        type: string

permissions:
  contents: write
  pull-requests: read

jobs:
  bump-version:
    name: Bump Version and Create Tag
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}  # pragma: allowlist secret
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      
      - name: Install bump2version
        run: pip install bump2version
      
      - name: Validate major version bump
        if: inputs.version_type == 'major'
        uses: actions/github-script@v7
        with:
          script: |
            // Check manual confirmation
            if (context.payload.inputs.confirm_major !== 'BREAKING') {
              core.setFailed('‚ùå Major version bump requires confirmation. Please enter "BREAKING" in the confirm_major field');
              return;
            }
            
            // Check for 'type: breaking' label on recent merged PRs
            core.info('Checking for breaking changes in recent PRs...');
            
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              sort: 'updated',
              direction: 'desc',
              per_page: 50
            });
            
            const mergedPRs = pullRequests.filter(pr => pr.merged_at);
            const breakingPRs = mergedPRs.filter(pr => 
              pr.labels.some(label => label.name === 'type: breaking')
            );
            
            if (breakingPRs.length === 0) {
              core.warning('‚ö†Ô∏è  No merged PRs with "type: breaking" label found in recent history');
              core.warning('Please verify that a major version bump is appropriate');
            } else {
              core.info('‚úì Found ' + breakingPRs.length + ' merged PR(s) with breaking changes:');
              breakingPRs.forEach(pr => {
                core.info('  - #' + pr.number + ': ' + pr.title);
              });
            }
      
      - name: Validate non-breaking version bump
        if: inputs.version_type != 'major'
        uses: actions/github-script@v7
        with:
          script: |
            // For minor and patch bumps, check that there are no breaking changes
            core.info('Checking that no breaking changes are present for ' + context.payload.inputs.version_type + ' bump...');
            
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              sort: 'updated',
              direction: 'desc',
              per_page: 50
            });
            
            const mergedPRs = pullRequests.filter(pr => pr.merged_at);
            const breakingPRs = mergedPRs.filter(pr => 
              pr.labels.some(label => label.name === 'type: breaking')
            );
            
            if (breakingPRs.length > 0) {
              core.warning('‚ö†Ô∏è  Found merged PRs with breaking changes:');
              breakingPRs.forEach(pr => {
                core.warning('  - #' + pr.number + ': ' + pr.title);
              });
              core.warning('Consider using a major version bump instead of ' + context.payload.inputs.version_type);
            } else {
              core.info('‚úì No breaking changes detected - ' + context.payload.inputs.version_type + ' bump is appropriate');
            }
      
      - name: Get current version
        id: current
        run: |
          CURRENT_VERSION=$(grep -E '^__version__ = ' reverse-engineer-python/reverse_engineer/__init__.py | cut -d'"' -f2)
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"
      
      - name: Calculate new version
        id: new
        run: |
          CURRENT="${{ steps.current.outputs.version }}"
          TYPE="${{ inputs.version_type }}"
          
          IFS='.' read -r major minor patch <<< "$CURRENT"
          
          case $TYPE in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac
          
          NEW_VERSION="$major.$minor.$patch"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"
      
      - name: Update Python package version files
        run: |
          NEW_VERSION="${{ steps.new.outputs.version }}"
          
          # Update __init__.py
          sed -i "s/__version__ = \".*\"/__version__ = \"$NEW_VERSION\"/" \
            reverse-engineer-python/reverse_engineer/__init__.py
          
          # Update setup.py
          sed -i "s/version=\".*\"/version=\"$NEW_VERSION\"/" \
            reverse-engineer-python/setup.py
          
          # Update pyproject.toml
          sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" \
            reverse-engineer-python/pyproject.toml
      
      - name: Update VS Code extension version files
        run: |
          NEW_VERSION="${{ steps.new.outputs.version }}"
          
          # Update package.json
          sed -i "s/\"version\": \".*\"/\"version\": \"$NEW_VERSION\"/" \
            vscode-extension/package.json
          
          # Update test-vsix.sh
          sed -i "s/VSIX_FILE=\"re-cue-.*\.vsix\"/VSIX_FILE=\"re-cue-$NEW_VERSION.vsix\"/" \
            vscode-extension/test-vsix.sh
      
      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
      
      - name: Create version bump branch
        run: |
          NEW_VERSION="${{ steps.new.outputs.version }}"
          BRANCH="release/v$NEW_VERSION"
          
          git checkout -b "$BRANCH"
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
        id: branch
      
      - name: Commit version changes
        run: |
          NEW_VERSION="${{ steps.new.outputs.version }}"
          
          git add reverse-engineer-python/reverse_engineer/__init__.py
          git add reverse-engineer-python/setup.py
          git add reverse-engineer-python/pyproject.toml
          git add vscode-extension/package.json
          git add vscode-extension/test-vsix.sh
          
          git commit -m "chore: bump version to $NEW_VERSION"
      
      - name: Push branch
        run: |
          git push origin "${{ steps.branch.outputs.branch }}"
      
      - name: Create Pull Request
        uses: actions/github-script@v7
        id: create_pr
        with:
          script: |
            const newVersion = '${{ steps.new.outputs.version }}';
            const bumpType = '${{ inputs.version_type }}';
            const currentVersion = '${{ steps.current.outputs.version }}';
            
            let body = '## Version Bump: ' + currentVersion + ' ‚Üí ' + newVersion + '\n\n';
            body += '**Bump type:** `' + bumpType + '`\n\n';
            body += '### Changes\n\n';
            body += 'This PR updates version numbers across all package files:\n\n';
            body += '- `reverse-engineer-python/reverse_engineer/__init__.py`\n';
            body += '- `reverse-engineer-python/setup.py`\n';
            body += '- `reverse-engineer-python/pyproject.toml`\n';
            body += '- `vscode-extension/package.json`\n';
            body += '- `vscode-extension/test-vsix.sh`\n\n';
            body += '### Post-Merge Actions\n\n';
            body += 'Once merged, this will:\n';
            body += '1. ‚úì Create git tag `v' + newVersion + '`\n';
            body += '2. ‚úì Trigger release workflows\n';
            body += '3. ‚úì Generate changelog\n';
            body += '4. ‚úì Publish packages\n\n';
            body += '---\n\n';
            body += '*This PR was created automatically by the Bump Version workflow.*\n';
            
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'chore: bump version to ' + newVersion,
              head: 'release/v' + newVersion,
              base: 'main',
              body: body
            });
            
            // Add the chore label to satisfy PR label requirements
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: ['type: chore']
            });
            
            core.info('Created PR #' + pr.number);
            return pr.number;
      
      - name: Enable PR auto-merge
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.create_pr.outputs.result }};
            
            // Get the PR to get its node ID
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            // Enable auto-merge using GraphQL
            const mutation = 'mutation($prId: ID!) { enablePullRequestAutoMerge(input: { pullRequestId: $prId, mergeMethod: SQUASH }) { pullRequest { number } } }';
            
            try {
              await github.graphql(mutation, {
                prId: pr.node_id
              });
              core.info('Auto-merge enabled for PR #' + prNumber);
            } catch (error) {
              core.warning('Could not enable auto-merge: ' + error.message);
              core.warning('You may need to merge the PR manually');
            }
      
      - name: Output summary
        uses: actions/github-script@v7
        with:
          script: |
            const currentVersion = '${{ steps.current.outputs.version }}';
            const newVersion = '${{ steps.new.outputs.version }}';
            const bumpType = '${{ inputs.version_type }}';
            
            // Get merged PRs since last release tag
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              sort: 'updated',
              direction: 'desc',
              per_page: 100
            });
            
            const mergedPRs = pullRequests.filter(pr => pr.merged_at);
            
            // Categorize PRs by label
            const categorizedPRs = {
              breaking: [],
              enhancement: [],
              bug: [],
              documentation: [],
              dependencies: [],
              security: [],
              performance: [],
              chore: [],
              other: []
            };
            
            mergedPRs.forEach(pr => {
              const labels = pr.labels.map(l => l.name);
              if (labels.includes('type: breaking')) categorizedPRs.breaking.push(pr);
              else if (labels.includes('type: enhancement')) categorizedPRs.enhancement.push(pr);
              else if (labels.includes('type: bug')) categorizedPRs.bug.push(pr);
              else if (labels.includes('type: documentation')) categorizedPRs.documentation.push(pr);
              else if (labels.includes('type: dependencies')) categorizedPRs.dependencies.push(pr);
              else if (labels.includes('type: security')) categorizedPRs.security.push(pr);
              else if (labels.includes('type: performance')) categorizedPRs.performance.push(pr);
              else if (labels.includes('type: chore')) categorizedPRs.chore.push(pr);
              else categorizedPRs.other.push(pr);
            });
            
            let summary = '## Version Bump Summary\n\n';
            summary += '- **Previous version:** ' + currentVersion + '\n';
            summary += '- **New version:** ' + newVersion + '\n';
            summary += '- **Bump type:** ' + bumpType + '\n';
            summary += '- **Git tag:** v' + newVersion + '\n\n';
            
            summary += '### Changes in This Release\n\n';
            
            if (categorizedPRs.breaking.length > 0) {
              summary += '#### üí• Breaking Changes\n';
              categorizedPRs.breaking.slice(0, 10).forEach(pr => {
                summary += '- #' + pr.number + ': ' + pr.title + '\n';
              });
              summary += '\n';
            }
            
            if (categorizedPRs.enhancement.length > 0) {
              summary += '#### ‚ú® Enhancements\n';
              categorizedPRs.enhancement.slice(0, 10).forEach(pr => {
                summary += '- #' + pr.number + ': ' + pr.title + '\n';
              });
              summary += '\n';
            }
            
            if (categorizedPRs.bug.length > 0) {
              summary += '#### üêõ Bug Fixes\n';
              categorizedPRs.bug.slice(0, 10).forEach(pr => {
                summary += '- #' + pr.number + ': ' + pr.title + '\n';
              });
              summary += '\n';
            }
            
            if (categorizedPRs.security.length > 0) {
              summary += '#### üîí Security\n';
              categorizedPRs.security.slice(0, 10).forEach(pr => {
                summary += '- #' + pr.number + ': ' + pr.title + '\n';
              });
              summary += '\n';
            }
            
            if (categorizedPRs.performance.length > 0) {
              summary += '#### ‚ö° Performance\n';
              categorizedPRs.performance.slice(0, 10).forEach(pr => {
                summary += '- #' + pr.number + ': ' + pr.title + '\n';
              });
              summary += '\n';
            }
            
            if (categorizedPRs.other.length > 0) {
              summary += '#### üìù Other Changes\n';
              summary += categorizedPRs.other.length + ' PR(s) without category labels\n\n';
            }
            
            summary += '\n---\n\n';
            summary += '### Next Steps\n\n';
            summary += '1. Review and merge PR #' + '${{ steps.create_pr.outputs.result }}' + '\n';
            summary += '2. Once merged, the tag-release workflow will create tag `v' + newVersion + '`\n';
            summary += '3. Release workflows will be triggered automatically\n';
            summary += '4. Changelog will be generated based on PR labels\n';
            
            await core.summary.addRaw(summary).write();

