name: PII Check

on:
  push:
  pull_request:

jobs:
  pii-check:
    runs-on: ubuntu-latest
    name: PII Check
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install detect-secrets
        run: |
          pip install detect-secrets
      
      - name: Run Secret Detection Scan
        id: secrets-scan
        run: |
          # Create baseline if it doesn't exist
          if [ ! -f .secrets.baseline ]; then
            detect-secrets scan --all-files --force-use-all-plugins \
              --exclude-files '.git/.*' \
              --exclude-files '.env' \
              --exclude-files 'node_modules/.*' \
              --exclude-files '.secrets.baseline' \
              > .secrets.baseline
          fi
          
          # Scan for sensitive data  # pragma: allowlist secret
          detect-secrets scan --baseline .secrets.baseline --all-files \
            --exclude-files '.git/.*' \
            --exclude-files '.env' \
            --exclude-files 'node_modules/.*' \
            > scan-results.json 2>&1 || true
          
          # Audit the results
          detect-secrets audit --report --json .secrets.baseline > audit-report.json 2>&1 || true
          
          # Create human-readable report
          cat > secrets-report.txt <<EOF
          === Secret Detection Report ===
          Generated: $(date)
          
          EOF
          
          # Check if secrets were found
          SECRET_COUNT=$(jq '.results | length' .secrets.baseline 2>/dev/null || echo "0")
          
          if [ "$SECRET_COUNT" -gt 0 ]; then
            echo "secrets_found=true" >> $GITHUB_OUTPUT
            echo "::warning::Potential secrets detected in the code"
            
            # Generate detailed report
            echo "Found $SECRET_COUNT file(s) with potential secrets:" >> secrets-report.txt
            echo "" >> secrets-report.txt
            
            jq -r '.results | to_entries[] | "File: \(.key)\n" + (.value[] | "  - Type: \(.type)\n    Line: \(.line_number)\n")' .secrets.baseline >> secrets-report.txt 2>/dev/null || echo "Error parsing results" >> secrets-report.txt
          else
            echo "secrets_found=false" >> $GITHUB_OUTPUT
            echo "No secrets detected" >> secrets-report.txt
          fi
          
          # Display report
          cat secrets-report.txt
      
      - name: Upload Scan Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: secret-detection-results
          path: |
            .secrets.baseline
            secrets-report.txt
            scan-results.json
            audit-report.json
      
      - name: Comment on PR
        if: github.event_name == 'pull_request' && steps.secrets-scan.outputs.secrets_found == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('scan-report.txt', 'utf8');  // pragma: allowlist secret
            
            const comment = `## üîí Secret Detection Results
            
            ‚ö†Ô∏è Potential secrets or sensitive data detected in this PR:
            
            \`\`\`
            ${report}
            \`\`\`
            
            **What to do:**
            1. Review the flagged items carefully
            2. Remove any actual secrets/credentials
            3. Use environment variables or secret management instead
            4. If these are false positives, they can be allowlisted
            
            **Detected patterns include:**
            - API Keys & Tokens (GitHub, AWS, Azure, etc.)
            - Private Keys & Certificates
            - Passwords & Connection Strings
            - High Entropy Strings (potential secrets)`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });