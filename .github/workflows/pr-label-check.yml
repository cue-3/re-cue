name: PR Label Check

on:
  pull_request:
    types: [opened, labeled, unlabeled, synchronize]
  workflow_run:
    workflows: 
      - "Auto-Label Pull Requests (Phase 1)"
      - "AI-Assisted Label Suggestion (Phase 2)"
    types:
      - completed
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to check'
        required: true
        type: number

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write

jobs:
  check-labels:
    name: Validate PR Labels
    runs-on: ubuntu-latest
    # Don't run on forks to avoid permission issues
    if: |
      (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository) ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Get PR number from workflow_run
        if: github.event_name == 'workflow_run'
        id: get-pr
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = github.event.workflow_run.pull_requests[0]?.number;
            if (!prNumber) {
              core.info('No PR found in workflow_run event');
              return;
            }
            core.setOutput('pr_number', prNumber);
            return prNumber;
      
      - name: Check for category label
        uses: actions/github-script@v7
        with:
          script: |
            let pr;
            let prNumber;
            
            if (context.eventName === 'workflow_run') {
              prNumber = '${{ steps.get-pr.outputs.pr_number }}';
              if (!prNumber) {
                core.info('Skipping check - no PR number available');
                return;
              }
              
              const { data: prData } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: parseInt(prNumber)
              });
              pr = prData;
            } else if (context.eventName === 'workflow_dispatch') {
              prNumber = ${{ inputs.pr_number }};
              
              const { data: prData } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              pr = prData;
            } else {
              pr = context.payload.pull_request;
              prNumber = pr.number;
            }
            
const categoryLabels = [
              'type: breaking',
              'type: enhancement',
              'type: bug',
              'type: documentation',
              'type: dependencies',
              'type: chore',
              'type: security',
              'type: performance'
            ];
            
            const prLabels = pr.labels.map(label => label.name);
            const categoryLabelsPresent = prLabels.filter(l => categoryLabels.includes(l));
            const hasCategoryLabel = categoryLabelsPresent.length > 0;
            
            // Get label application history to identify auto-applied vs manual
            const { data: events } = await github.rest.issues.listEvents({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              per_page: 100
            });
            
            const labelEvents = events.filter(e => 
              e.event === 'labeled' && 
              e.label && 
              categoryLabels.includes(e.label.name)
            );
            
            const autoApplied = labelEvents
              .filter(e => e.actor.type === 'Bot' || e.actor.login === 'github-actions[bot]')
              .map(e => e.label.name);
            
            const manuallyAdded = categoryLabelsPresent.filter(l => !autoApplied.includes(l));
            
            if (!hasCategoryLabel) {
              const comment = '## âš ï¸ Missing Category Label\n\n' +
                'This pull request requires at least one category label before it can be merged.\n\n' +
                '**Available category labels:**\n\n' +
                '| Label | Description | Changelog Section |\n' +
                '|-------|-------------|-------------------|\n' +
                '| `type: breaking` ðŸ’¥ | Breaking changes requiring major version bump | Breaking Changes |\n' +
                '| `type: enhancement` âœ¨ | New features and enhancements | Added |\n' +
                '| `type: bug` ðŸ› | Bug fixes | Fixed |\n' +
                '| `type: documentation` ðŸ“š | Documentation updates | Changed |\n' +
                '| `type: dependencies` â¬†ï¸ | Dependency updates | Dependencies |\n' +
                '| `type: chore` ðŸ”§ | Maintenance and chores | Maintenance |\n' +
                '| `type: security` ðŸ”’ | Security fixes | Security |\n' +
                '| `type: performance` âš¡ | Performance improvements | Performance |\n\n' +
                '**Please add at least one label** to this PR. You can add multiple labels if the PR covers multiple categories.\n\n' +
                'ðŸ’¡ **Tip**: Labels may be automatically suggested based on your PR content. Check for AI suggestions below!\n\n' +
                '*This check will automatically pass once a category label is added.*';
              
              // Post comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: comment
              });
              
              // Fail the check
              core.setFailed('PR is missing a required category label');
            } else {
              // Build label summary showing auto vs manual
              let labelSummary = 'âœ“ PR has ' + categoryLabelsPresent.length + ' category label(s):\n\n';
              
              if (autoApplied.length > 0) {
                labelSummary += '**ðŸ¤– Auto-applied:**\n' + autoApplied.map(l => '- `' + l + '`').join('\n') + '\n\n';
              }
              
              if (manuallyAdded.length > 0) {
                labelSummary += '**ðŸ‘¤ Manually added:**\n' + manuallyAdded.map(l => '- `' + l + '`').join('\n') + '\n\n';
              }
              
              labelSummary += '**Please verify** these labels accurately reflect your changes. ';
              labelSummary += 'Your corrections help improve the auto-labeling system! ðŸŽ¯';
              
              console.log(labelSummary);
              
              // Find and delete old bot comments about missing labels
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number
              });
              
              for (const comment of comments.data) {
                if (comment.user.type === 'Bot' && 
                    comment.body.includes('Missing Category Label')) {
                  await github.rest.issues.deleteComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: comment.id
                  });
                }
              }
            }
